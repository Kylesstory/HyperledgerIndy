\documentclass{article}
\usepackage{amsmath}
\usepackage{amsfonts}
\usepackage{algorithm}
\usepackage{algpseudocode}
\usepackage{hyperref}
\hypersetup{
    colorlinks=true,
    linkcolor=blue,
    filecolor=magenta,      
    urlcolor=cyan,
}
% \usepackage[linesnumbered,boxed]{algorithm2e}

\include{commands}

\begin{document}
\title{Cryptography of Hyperledger Indy}
\author{Kyle Huang}
\maketitle

\section{Syntax of Hyperledger Indy}
The first four steps are similar to the register operation, and the last four steps look like login.\footnote{All content refers to \href{https://hyperledger-indy.readthedocs.io/projects/hipe/en/latest/text/0109-anoncreds-protocol/README.html}{Hyperledger Indy HIPE}.}
\begin{enumerate}
\item Issuer determines a credential schema $\mc{S}$: the type of cryptographic signatures used to sign the credentials, the number $l$ of attributes in a credential, the indices $\ah \subset [1, l] = \{1, 2, ..., l\}$ of hidden attributes, the public key $P_{k}$, the non-revocation credential attribute number $l_{r}$ and non-revocation public key $P_{r}$. Then he publishes it on the ledger and announces the attribute semantics.
\item Holder retrieves the credential schema from the ledger and sets the hidden attributes.
\item Holder requests a credential from issuer. He sends hidden attributes in a blinded form to issuer and agrees on the values of known attributes $\ak \la [1, l] \backslash \ah $.
\item Issuer returns a credential pair $(C_{p}, C_{NR})$ to holder. The first credential contains the requested $l$ attributes. The second credential asserts the non-revocation status of the first one. Issuer publishes the non-revoked status of the credential on the ledger.
\item Holder approaches verifier. Verifier sends the Proof Request $\mc{E}$ to holder. The Proof Request contains the credential schema $\mc{S}_{E}$ and disclosure predicates $\mc{D}$. The predicates for attribute $m$ and value $V$ can be of form $m=V$, $m<V$, or $m>V$. Some attributes may be asserted to be the same: $m_{i}=m_{j}$.
\item Holder checks that the credential pair he holds satisfies the schema $\mc{S}_{E}$. He retrieves the non-revocation witness from the ledger.
\item Holder creates a proof $\mc{P}$ that he has a non-revoked credential satisfying the proof request $\mc{E}$ and sends it to verifier.
\item Verifier verifies the proof.
\end{enumerate}

\section{Environment setup}
Issuer generates the key pair $(\keypair{k})$ through $setup_{PC}(l)$ (Algorithm \ref{alg:pcsetup}), key pair $(\keypair{r})$ through $setup_{NR}()$ (Algorithm \ref{alg:nrsetup}) and a proof $\mc{P}_{1}$ ; then, he keeps $(s_{k}, s_{r})$ secret and publishes $(\mc{S}, \ah , l_{r}, P_{k}, P_{r}, \mc{P}_{1})$ to the ledger. Everyone can verify the correctness of $P_{k}$ (via proof $\mc{P}_{1}$) through $verify_{P_{k}}(l, P_{k}, \mc{P}_{1})$ (Algorithm \ref{alg:pcverify}).

\subsection{Primary Credemtial (CL-Signature)}

\begin{algorithm}
\caption{$setup_{PC}(l)$}
\label{alg:pcsetup}
\begin{algorithmic}
	\State $p',q'\lar \binbits{1536}$
	\Comment{$p'$ and $q'$ are prime; $|p'|=|q'|=1536$}
	\State $p\la 2p'+1$; $q\la 2q'+1$; $n\la pq$
	\Comment{$p$ and $q$ are prime}
	\State $t\lar \mbz{n}$; $\equivmod{S}{t^2}{n}$
	\State $\randexpm{x_{z}}{p'q'}{Z}{S}{n}$
	\State $\group{\randexpm{x_{r_i}}{p'q'}{R_{i}}{S}{n}}{i}{[1,l]}$
	\State $\keypairv{k}{\pk}{(p,q)}$
	\State $\randexpm{\td{x}_{z}}{p'q'}{\td{Z}}{S}{n}$
	\Comment Correctness proof from here.
	\State $\group{\randexpm{\td{x}_{r_i}}{p'q'}{\td{R}_{i}}{S}{n}}{i}{[1,l]}$
	\State $c\la H_{1}(Z||\td{Z}||\group{R_i,\td{R}_i}{i}{[1,l]})$
	\Comment $H_1$ is by default SHA2-256
	\State $\zkp{x}{z}$; $\group{\zkp{x}{r_{i}}}{i}{[1,l]}$
	\State $\mc{P}_{1}\la \pl$
	\State \Return $(\keypair{k}, \mc{P}_{1})$
\end{algorithmic}
\end{algorithm}

\begin{algorithm}
\caption{$verify_{P_{k}}(l, P_{k}, \mc{P}_{1})$}
\label{alg:pcverify}
\begin{algorithmic}
	\State $\pk \la P_{k}$; $\pl \la \mc{P}_{1}$
	\State $\zkv{Z}{}{S}{x}{_{z}}$; $\group{\zkv{R}{i}{S}{x}{_{r_{i}}}}{i}{[1,l]}\pmod{n}$
	\State \Return $c==H_{1}(Z||\td{Z}||\group{R_i,\td{R}_i}{i}{[1,l]})$
\end{algorithmic}
\end{algorithm}
\clearpage
\subsection{Non-Revocation Credential}
\begin{algorithm}
\caption{$setup_{NR}()$}
\label{alg:nrsetup}
\begin{algorithmic}
	\State $\mbg{1}\times \mbg{2} \rightarrow \mbg{T}$
	\Comment Pick a type-III pairing where $|\mbg{1}|=|\mbg{2}|=|\mbg{T}|=q$
	\State $g\lar \mbg{1}$; $g'\lar \mbg{2}$
	\State $h, h_0, h_1, h_2, \td{h}\lar \mbg{1}$; $u, \hat{h}\lar \mbg{2}$
	\State $\randexp{sk}{q}{pk}{g}$; $\randexp{x}{q}{y}{\hat{h}}$
	\State $\keypairv{r}{\pr}{(sk, x)}$
	\State \Return $(\keypair{r})$
\end{algorithmic}
\end{algorithm}
\subsection{CKS Accumulator}
Issuer creates a new accumulator using $setup_{Acc}(L, P_{r})$ (Algorithm \ref{alg:nracc}).
\begin{algorithm}
\caption{$setup_{Acc}(L, P_{r})$}
\label{alg:nracc}
\begin{algorithmic}
	\State $r\lar \mbz{q}$; $\group{g_{i}\la g^{r^{i}}, g'_{i}\la g'^{r^{i}}}{i}{[1, 2L] \backslash \{L + 1\}}$
	\State $z\la \pairing{g}{g'}{r^{L + 1}}$; $V\la \emptyset$; $acc\la 1$
	\State $\keypairv{a}{z}{r}$
	\State \Comment Issuer publishes $(P_{a}, V)$ on the ledger with identifier $ID_{a} \la z$.
	\State \Return $(\keypair{a}, V, acc)$
\end{algorithmic}
\end{algorithm}


\clearpage
\section{Credential Issuance}
Let $\mc{H}$ be the identifier of the holder in the issuer's system. The holder acquires the schema $\mc{S}$, indice $\ah$ and public keys $(P_{k}, P_{r})$ from the ledger in addition to a random number $n_0$ and the identifier $\mc{H}$ from the issuer; then he sets the hidden attribute $\group{m_i}{i}{\ah}$. The credential issuance process is interactive, which follows: 
\begin{enumerate}
	\item The holder computes a temporary result $(\keypair{h})$ by excuting (Algorithm \ref{alg:ci1issue}) $\issuehp$; then, he keeps $s_{h}$ private and sends $P_{h}$ to the issuer. Everyone can verify the correctness through $verify_{P_{h}}(P_{k}, P_{h})$ (Algorithm \ref{alg:ci1verify}).
\end{enumerate}
\subsection{The holder phase (step 1)}

\begin{algorithm}
\caption{$\issuehp$}
\label{alg:ci1issue}
\begin{algorithmic}
	\State $\group{\td{m}_i\lar \binbits{593}}{i}{\ah}$
	\Comment Primary credential
	\State $v'\lar \binbits{3152}$; $\td{v}'\lar \binbits{3488}$
	\State $\pk \la P_{k}$
	\State $U\la S^{v'}\prodi{i}{\ah}{R_{i}^{m_{i}}}$; $\td{U}\la S^{\td{v}'}\prodi{i}{\ah}{R_{i}^{\td{m}_{i}}}$
	\State $c = H(U||\td{U}||n_{0})$; $n_1\lar \binbits{80}$
	\State $\zkp{v}{}$; $\group{\zkp{m}{i}}{i}{\ah}$
	\State $\pr \la P_{r}$
	\Comment Non-revocation credential
	\State $\randexp{s'}{q}{U_{r}}{h_{2}}$
	\State $\keypairv{h}{\ph }{(v',s')}$
	\State \Return $(\keypair{h})$
\end{algorithmic}
\end{algorithm}

\begin{algorithm}
\caption{$verify_{P_{h}}(P_{k}, P_{h})$}
\label{alg:ci1verify}
\begin{algorithmic}
	\State $\pk \la P_{k}$; $\ph \la P_{h}$
	\State $\zkv{U}{}{S}{v}{'}\prodi{i}{\ah}{S^{\hat{m}_{i}}R_{i}^{-c}}$
	\State \Return $c == H(U||\td{U}||n_{0})$
\end{algorithmic}
\end{algorithm}

\clearpage
\subsection{The issuer phase (step 2)}
Let $i<L$ denotes an identifier to holder, the issuer processes the following algorithms.
\begin{algorithm}
\caption{$verify_{P_{h}}(P_{k}, P_{h})$}
\label{alg:civerify}
\begin{algorithmic}
	\State $\pk \la P_{k}$; $\ph \la P_{h}$
	\State $\zkv{U}{}{S}{v}{'}\prodi{i}{\ah}{S^{\hat{m}_{i}}R_{i}^{-c}}$
	\State \Return $c == H(U||\td{U}||n_{0})$
\end{algorithmic}
\end{algorithm}

\end{document}
