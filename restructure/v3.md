# CCIS redesign v3

**Define** 
- (P_x, S_x) as the public key and secret key pair over x. 
- common_parameters (g, g') is shared by all roles in the CCIS system.

## Storage

- Issuer
	- known_attributes (A_k)
	- identities of holders (ID_H)
	- secret key for primary credential (S_P)

- Carrier(Issuer)
	- accumulator detail (V, z, {g_i, g_i'} for i in [1, 2L])
	- secret key for non-revocation (S_NR)
	- secret key for accumulator (S_acc)

- Blockchain
	- schema 
	- credential_definition (P_K, P_NR, schema)
	- epoch (z, acc)

- Carrier(Holder)
	- random numbers (n_0 [n_1])
	- non-revocation credential (C_NR)
	- encrypted primary credential (C_P_cipher)

- Holder
	- hidden_attributes (A_h)
	- primary credential (C_P)

## Flows

### Setup

#### Schema creation
1. Issuer
	- schema <- create_schema()
	- send(Carrier(Issuer), schema)
2. Carrier(Issuer)
	- Blockchain.register_schema(schema)

#### Credential definition creation
1. Issuer
	- send(Carrier(Issuer), schema_index)
2. Carrier(Issuer)
	- schema <- Blockchain.read_schema(schema_index)
	- send(Issuer, schema)
3. Issuer
	- (P_K, S_K) <- create_credential_definition(schema)
	- send(Carrier(Issuer), (schema, P_K))
	- privately_keep(S_K)
4. Carrier(Issuer)
	- (P_NR, S_NR) <- create_credential_definition(schema, P_K)
	- privately_keep(S_NR)
	- Blockchain.register_credential_definition(schema, P_K, P_NR)

#### Accumulator creation
1. Carrier(Issuer)
	- (indice, acc, P_acc, S_acc, parameters, epoch) <- create_accumulator();
	- privately_keep(indice, S_acc, parameters)
	- Blockchain.register_epoch(epoch)

### Issuance
1. Issuer
	- send(Holder, cred_def_index) <!-- in person or remote -->
2. Holder
	- send(Carrier(Holder), cred_def_index) <!-- bio-authenticated recommended -->
3. Carrier(Holder)
	- token <- create_issuance_token() <!-- token: n_0 -->
	- cred_def <- get_credential_definition(cred_def_index)
	- send(Holder, (token, cred_def))
4. Holder
	- (C_P_request, C_P_param, C_NR_token) <- request_for_primary_credential(n_0, cred_def, A_h) <!-- C_P_param: r'', C_NR_token: n_1 -->
	- DH_Holder, DH_Holder_source <- create_half_DH_key()
	- send(Carrier(Holder), (cred_def, C_P_request, C_NR_token, DH_Holder))
5. Carrier(Holder)
	- (C_NR_request, C_NR_param) <- request_for_NR_credential(cred_def) <!-- C_NR_param: s'' -->
	- send(Carrier(Issuer), (cred_def, C_P_request, C_NR_request, DH_Holder))
6. Carrier(Issuer)
	- (i, P_acc) <- iterate(cred_def) <!-- P_acc: id of accumulator -->
	- send(Issuer, (i, cred_def, C_P_request, DH_Holder))
7. Issuer
	- C_P_response <- create_primary_credential_response(S_K, i, cred_def, C_P_request)
	- DH_Issuer, DH_Issuer_source <- create_half_DH_key()
	- one_time_key <- derive_one_time_key(DH_Issuer_source, DH_Holder)
	- EC_P <- one_time_encrypt(one_time_key, C_P_response)
	- send(Carrier(Issuer), (ID_H, EC_P, DH_Issuer))
8. Carrier(Issuer)
	- (C_NR_response, epoch) <- create_NR_credential_response(S_NR, S_acc, ID_H, P_acc, cred_def, C_NR_request)
	- send(Carrier(Holder), (ID_H, EC_P, C_NR_response, DH_Issuer))
	- Blockchain.update_epoch(epoch)
10. Carrier(Holder)
	- send(Holder, ID_H, EC_P, DH_Issuer)
11. Holder
	- one_time_key <- derive_one_time_key(DH_Holder_source, DH_Issuer)
	- C_P_response <- one_time_decrypt(one_time_key, EC_P)
	- C_P <- finish_primary_credential(C_P_response, C_P_param)
	- C_P_cipher <- hardware_symmetric_encrypt(C_P)
	- send(Carrier(Holder), C_P_cipher)
	- privately_keep(C_P)
12. Carrier(Holder)
	- C_NR <- finish_NR_credential(C_NR_response, C_NR_token, C_NR_param)
	- privately_keep(cred_def_index, C_P_cipher, C_NR)

### Revocation 
<!-- may be triggered by Issuer or Carrier(Holder) -->
1. Carrier(Issuer)
	- (P_acc, i) <- find(ID_H)
	- epoch <- revoke(P_acc, i)
	- Blockchain.update_epoch(epoch)

### Verification
1. Verifier <!-- in person or remote -->
	- DH_Verifier, DH_Verifier_source <- create_half_DH_key()
	- proof_request <- proof_request(VRD, indices, predicates)<!-- indices: indices of revealing attributes; predicates: {i, P_i} for all i in hidden attributes -->
	- send(Holder, (proof_request, DH_Verifier)) 
2. Holder
	- send(Carrier(Holder), VRD) <!-- bio-authenticated recommended -->
3. Carrier(Holder)
	- {cred_list, C_P_cipher, C_NR} <- validate_credentials(VRD)
	- send(Holder, {C_P_cipher}) <!-- {x}: may be zero, one or multiple x -->
4. Holder
	- {C_P} <- hardware_symmetric_decrypt({C_P_cipher})
	- {revealed_attributes} <- {C_P}
	- {primary_proof} <- primary_prove({C_P}, VRD)
	- DH_Holder, DH_Holder_source <- create_half_DH_key()
	- one_time_key <- derive_one_time_key(DH_Holder_source, DH_Verifier)
	- encrypted_attributes <- one_time_encrypt(one_time_key, {revealed_attributes})
	- send(Carrier(Holder), ({primary_proof}, encrypted_attributes))
5. Carrier(Holder)
	- send(Carrier(Issuer), {witness_old}) <!-- to update witness -->
6. Carrier(Issuer)
	- {witness} <- update_witness({witness_old})
	- send(Carrier(Holder))
7. Carrier(Holder)
	- proof <- prove({primary_proof}, {witness}, {C_NR})
	- send(Carrier(Verifier), proof)
8. Carrier(Verifier)
	- epoch <- Blockchain.read_epoch()
	- send(Verifier, (epoch, proof))
9. Verifier
	-  1/0 <- verify(epoch, proof)

## Functions

- Overall
	- send(destination, data)
	- privately_keep(data)
	- create_half_DH_key()
	- derive_one_time_key(DH_key_A_source, DH_key_B) <!-- ensure the input DH_key is signed and verified -->
	- one_time_encrypt(one_time_key, data)
	- one_time_decrypt(one_time_key, cipher)

- Issuer
	- create_schema()
	- read_schema()
	- create_credential_definition()
	- create_primary_credential_response()

- Carrier(Issuer)
	- create_credential_definition()
	- create_accumulator()
	- create_NR_credential_response()
	- iterate()
	- find()
	- revoke()
	- update_witness() 

- Blockchain
	- register_schema(schema)
	- register_credential_definition(credential_definition)
	- register_epoch(epoch)
	- read_schema(schema_index)
	- read_epoch(epoch_index)
	- update_epoch(epoch_index, content)

- Carrier(Holder)
	- request_for_NR_credential()
	- finish_NR_credential()
	- validate_credentials()
	- get_credential_definition() <!-- from blockchain -->
	- create_issuance_token()
	- revoke()
	- prove()

- Holder
	- request_for_primary_credential()
	- finish_primary_credential()
	- primary_prove()
	- hardware_symmetric_encrypt()
	- hardware_symmetric_decrypt()

- Verifier
	- proof_request()
	- verify()


